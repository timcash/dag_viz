# DAG Viz v2.0 - 30-Step Atomic Development & Testing Guide

## Core Concepts
The v2.0 system visualizes a complex Directed Acyclic Graph (DAG) across multiple 3D planes. Each **Layer** is a 2D plane in 3D space where nodes are rendered as a DAG from **left to right**. Nodes are organized into **Ranks** (vertical columns). Nodes are not just static boxes; they are gateways to further complexity. A node can have multiple **Inputs** and **Outputs** (Edges), and can encapsulate a **Sub-layer** containing its own nested DAG.

### Glossary
- **Layer**: A 2D plane within 3D space (`THREE.Group`) where a graph is laid out. Layers are stacked vertically (on the Y-axis). Nodes on a layer are arranged in a **left-to-right** DAG flow.
- **Current Layer**: The specific layer that is currently active for interaction. Highlighting, node creation, and the establishment of new inputs/outputs (linking) only occur on the Current Layer.
- **Node**: A 3D entity representing a task or data point. Contains `inputs` (incoming edges), `outputs` (outgoing edges), and an optional `sub-layer`.
- **Rank**: A vertical column within a layer. Nodes in Rank 0 form the leftmost column.
- **Rank Constraint**: A fundamental DAG rule where any node must have a higher rank (be further to the right) than any node providing its inputs. This ensures the graph flows strictly in one direction.
- **Hover Node**: The specific node currently under the user's mouse pointer. Hovering triggers visual feedback (e.g., emissive glow) and activates the **Transient Visibility** of any associated sub-layer.
- **Edge**: A directed, curved visual connection (Bezier) between an output of one node and an input of another, flowing left-to-right.
- **Sub-layer**: A nested graph belonging to a specific "parent" node.
- **Persistent Visibility**: Architecture where parent layers remain visible in the background when the user navigates deeper into sub-layers.
- **Transient Visibility**: The behavior where sub-layers are hidden by default and only appear when their parent node is hovered or clicked.
- **Dive**: The transition of the camera moving from a global view of a layer to a focused view of a specific node's sub-layer.
- **Navigation Path**: An ordered stack of nodes that the user has "dived" into. This represents the user's current depth and lineage within the nested DAG.
- **Path Scrubbing**: The interaction of using the mouse scroll wheel to move forward or backward along the **Navigation Path**. Scrolling up moves the camera to the parent layer; scrolling down moves it back into the previously dived sub-layer.
- **Thumb Button**: Large, high-contrast UI elements positioned in the bottom corners of the screen. Designed for ergonomic "thumb" access on mobile/touch devices.
- **Expandable Menu**: A vertical fly-out menu triggered by a Thumb Button, containing secondary actions like "Add Node," "Delete," or "Reset Camera."

## User Interaction Guide (How it works)

### 1. Exploring the Graph
- **Peeking**: Hover your mouse over any node to "peek" inside. Its sub-layer will fade in below it so you can see what's inside without leaving your current view.
- **Diving In**: Click on a node to travel down into its sub-layer. The camera will glide smoothly to center on the new graph.
- **The "Safety Net"**: As you dive deeper, the layers above you stay visible. This helps you remember where you came from.

### 2. Moving Around (Navigation)
- **Scrubbing the Path**: Use your mouse scroll wheel like a "Back" and "Forward" button. Scroll **Up** to pull back to the parent layer. Scroll **Down** to dive back into the sub-layer you just left.
- **Panning**: Use WASD keys to slide the camera around the current layer.
- **Quick Actions**: Use the **Thumb Buttons** in the bottom corners for common tasks. Tap them to expand a menu of options, like adding nodes or clearing the graph.

### 3. Building the DAG
- **Adding Nodes**: Double-click on any empty space on the current layer's floor OR use the "+" button in the Thumb Menu.
- **Linking Nodes**: Hold **Ctrl** and click two nodes to draw a connection between them.
- **Automatic Organizing**: The system handles the "Ranks" for you. If you link Node A to Node B, Node B will automatically jump to a vertical column to the right of Node A to keep the flow strictly left-to-right.
- **Removing**: Select a node and press **Delete** (or use the trash icon in the Thumb Menu) to remove it and all its connections.

---

## Phase 1: Infrastructure & Basic Rendering

### Step 0: Error Interception (The Error-Ping)
- **Goal**: Verify Puppeteer can catch browser errors.
- **Test Conditions**:
    - Page loads with `?error-ping` query parameter.
    - Puppeteer catches `pageerror` event.
    - Error message matches "Smoke Test Error".

### Step 1: WebGL Initialization
- **Goal**: Basic Three.js setup.
- **Test Conditions**:
    - `canvas` element exists in the DOM.
    - WebGL2 context is successfully initialized.
    - Camera is at `(0, 0, 5)` looking at `(0, 0, 0)`.

### Step 2: Clear Color & Scene
- **Goal**: Set background color.
- **Test Conditions**:
    - `renderer.getClearColor()` returns RGB `(0, 0, 0)`.
    - Viewport pixels are all black when scene is empty.

### Step 3: Perspective Camera Setup
- **Goal**: Ensure camera exists with correct perspective.
- **Test Conditions**:
    - `camera.position.z` is `5`.
    - `camera.fov` is `60`.
    - `camera.aspect` matches `window.innerWidth / window.innerHeight`.

### Step 4: Simple Light Source
- **Goal**: Add an AmbientLight and verify rendering.
- **Test Conditions**:
    - `scene` contains at least one `AmbientLight` object.
    - A white cube at `(0, 0, 0)` is rendered with non-zero brightness at screen center.

---

## Phase 2: Node & Layer Architecture

### Step 5: The "Layer" Group
- **Goal**: Implement `Layer` as a container.
- **Test Conditions**:
    - A `THREE.Group` exists in the scene.
    - Group has `userData.type === 'layer'`.
    - Group position is at `(0, 0, 0)`.

### Step 6: Single Node Geometry
- **Goal**: Render a 3D box representing a node.
- **Test Conditions**:
    - A `Mesh` exists within the Layer group.
    - Node geometry size is `(2, 0.2, 1)`.
    - Camera at `(0, 5, 10)` sees the node at screen center.

### Step 7: Node Label (2D Texture)
- **Goal**: Map a label to the node top face.
- **Test Conditions**:
    - Node mesh material has a `map` (texture) assigned.
    - Screen center pixel (on node top) returns white (label text).
    - Neighboring pixel on same face returns black (node body).

### Step 8: Multi-Node Layout
- **Goal**: Render multiple nodes with distinct positions.
- **Test Conditions**:
    - Three node meshes exist in the layer.
    - Node positions are `(0, 0, 0)`, `(5, 0, 0)`, and `(10, 0, 0)`.

### Step 9: Layer Ground Plane
- **Goal**: Add a spatial reference plane.
- **Test Conditions**:
    - A `PlaneGeometry` mesh exists at `y = 0`.
    - Plane dimensions are `100x100`.
    - Plane rotation is `-90` degrees on X-axis.

---

## Phase 3: DAG Edge Rendering

### Step 10: Basic Straight Edge
- **Goal**: Connect two nodes with a line.
- **Test Conditions**:
    - A `Line` or `LineSegments` object exists in the scene.
    - Line vertices exactly match positions of Node A `(0,0,0)` and Node B `(10,0,0)`.

### Step 11: Curved Edge (Bezier)
- **Goal**: Implement curved visual connections.
- **Test Conditions**:
    - Line geometry contains more than 2 vertices (indicates a curve).
    - Curve peak (Y-max) is at approximately `Y = 2` between nodes at `Y = 0`.

### Step 12: Edge Opacity/Weighting
- **Goal**: Verify visual weighting of edges.
- **Test Conditions**:
    - `edge.material.opacity` is set to `0.5`.
    - Pixel sampling on the line returns intermediate alpha/brightness values.

### Step 13: Rank Constraint Enforcement
- **Goal**: Auto-position nodes based on flow.
- **Test Conditions**:
    - Create an edge from Node A to Node B.
    - `NodeB.position.x` is verified to be greater than `NodeA.position.x` (e.g., `X_B >= X_A + 10`).

---

## Phase 4: Interaction & Hover Logic

### Step 14: Raycaster Accuracy
- **Goal**: Verify mouse-to-3D projection.
- **Test Conditions**:
    - Camera at `(0, 10, 0)` looking down.
    - Node at `(0, 0, 0)`.
    - Mouse at screen center returns the node as first intersection.

### Step 15: Node Hover Visuals
- **Goal**: Feedback on mouse over.
- **Test Conditions**:
    - Move mouse to screen center.
    - `node.material.emissive` color changes from `0x000000` to `0x0066ff`.

### Step 16: Sub-layer Instantiation
- **Goal**: Nested graph creation.
- **Test Conditions**:
    - Parent node has a `subLayer` property (instance of `Layer`).
    - Sub-layer group position Y is exactly `20` units below parent (`Y = -20`).

### Step 17: Sub-layer Visibility (Enter)
- **Goal**: Reveal sub-layer on hover.
- **Test Conditions**:
    - Hover over Node A.
    - `NodeA.subLayer.group.visible` is `true`.

### Step 18: Sub-layer Visibility (Exit)
- **Goal**: Hide sub-layer on mouse leave.
- **Test Conditions**:
    - Move mouse to `(0,0)`.
    - `NodeA.subLayer.group.visible` is `false`.

### Step 19: Hover Persistence (Nested)
- **Goal**: Maintain sub-layer when interacting with children.
- **Test Conditions**:
    - Hover Node A (Parent).
    - Move mouse into Node A's sub-layer (child node).
    - `NodeA.subLayer.group.visible` remains `true`.

---

## Phase 5: Simplified Navigation & Pathing

### Step 20: Click to Dive
- **Goal**: Trigger layer transition on click.
- **Test Conditions**:
    - Click Node A at screen center.
    - `navigationPath` array contains Node A's ID as the last element.

### Step 21: Camera Translation (Center)
- **Goal**: Re-center camera on active focus.
- **Test Conditions**:
    - Camera `(x, z)` coordinates match target node `(x, z)` after transition.
    - `camera.lookAt` target is at target node position.

### Step 22: Camera Zoom (Dive)
- **Goal**: Vertical movement between layers.
- **Test Conditions**:
    - Camera Y moves from `0` to `-10` (focused view of sub-layer at `Y = -20`).

### Step 23: Parent Visibility (Persistence)
- **Goal**: Keep context of higher layers.
- **Test Conditions**:
    - While camera is at `Y = -10`, verify layer at `Y = 0` is still `visible`.
    - Verify layer at `Y = 0` has reduced opacity (dimmed).

### Step 24: Path Scrubbing (Scroll Up)
- **Goal**: Navigate back using scroll wheel.
- **Test Conditions**:
    - Simulate mouse wheel `deltaY < 0`.
    - Camera Y returns to parent level `(Y = 10)`.
    - `navigationPath` length decreases by 1.

### Step 25: Path Scrubbing (Scroll Down)
- **Goal**: Navigate forward into the path history.
- **Test Conditions**:
    - Simulate mouse wheel `deltaY > 0`.
    - Camera Y returns to sub-layer level `(Y = -10)`.
    - `navigationPath` restores the child node ID.

---

## Phase 6: Advanced UI & State

### Step 26: Breadcrumb Tracking
- **Goal**: Sync HUD with 3D state.
- **Test Conditions**:
    - Element `.breadcrumb` text content is "Root > Node A".
    - Breadcrumb updates immediately after Dive click.

### Step 27: Thumb Button Layout
- **Goal**: UI ergonomics for mobile.
- **Test Conditions**:
    - `.thumb-button.left` exists at bottom-left screen corner.
    - `.thumb-button.right` exists at bottom-right screen corner.

### Step 28: Expandable Menu Interaction
- **Goal**: Sub-menu accessibility.
- **Test Conditions**:
    - Click Thumb Button.
    - `.sub-menu` CSS class contains `active`.
    - Sub-menu visibility/opacity is `1`.

### Step 29: HUD Mini-Map
- **Goal**: Global context overview.
- **Test Conditions**:
    - `.minimap` element exists.
    - `minimap.getContext('2d')` has non-transparent pixel data.

### Step 30: Final Smoke Test
- **Goal**: Full system integration.
- **Test Conditions**:
    - Execute sequence: Hover Node -> Click Node -> Scroll Up -> Scroll Down.
    - Verify camera position and layer visibility at each step.
    - Add a node via Thumb Menu; verify node exists at `Y = -20`.
